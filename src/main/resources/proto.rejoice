# Rejoice!

# Natives
#
# A native is a function or macro that is provided by the runtime.
# Declaring them in a source file is for documentation purposes.

# Native Macros

native native
  #syn "; >>"
  #doc "A macro for documenting a native function or macro"
;

native (
  #syn "( ~& body ) >> ~'@ body ~$ body list"
  #doc "A macro that creates a list from the input stream."
;

native [
  #syn "[ ~& body ] >> ~'@ body ~$ body stack"
  #doc "A macro that creates a stack from the input stream."
;

native function
  #syn "function ~% name ^symbol : ~& body ; >> ( ~@ body ) ~'@ name define-function"
  #doc "A macro that defines a named function."
;

native protocol
  #syn "protocol ~% name ^symbol ; >> ( ~@ body ) ~'@ name define-protocol"
  #doc "A macro that defines a named protocol."
;

native extend
  #syn "extend ~% name ^symbol ~% type ^type : ~& body ; >> ( ~@ body ) ~'@ name ~@type extend-protocol"
  #doc "A macro that extends a protocol with a function for a single value of the specified type."
;

# Native Functions

native if
  # "Expects three lists: p, t, and f (where f is the top of th stack).
  # Evaluates p (the predicate) against a copy of the stack with out p, t, or f.
  # If it yields true, then t is evaluated, otherwise f is evaluated."
;

native lift
  #eff "... x ... ^i64 -- ... x"
  #doc "Expects an integer on the stack. After popping it, moves the element from the desired position to position one. The program '1 lift' is a no-op."
;

native sink
  #doc "Expects an integer on the stack. After popping it, moves the element from position one to the desired position. The program '1 sink' is a no-op."
;

native list
  #eff "a ... ^i64 -- ^list"
  #doc "Creates a list with n elements, consuming them from the main stack."
;

native stack
  #eff "a ... ^i64 -- ^stack"
  #doc "Creates a stack with n elements, consuming them from the main stack."
;

native cons
  #eff "x ^list -- ^list"
  #doc "Adds x to the front of the list."
;

native demote
  #eff "-- ^stack"
  #doc "Pushes the existing stack onto a new main stack."
;

native promote
  #eff "^stack --"
  #doc "Expects the top element to be a stack. Makes that stack the new main stack."
;

native stack-apply
  #eff "^list ^stack -- ^stack
  #doc "Expects the top element to be a stack. Evaluates the List with the stack, instead of the main stack."
;

native peek
  #eff "^stack -- x ^stack"
  #doc "Expects the top element to be a stack. Pushes a copy of top element of that stack onto the main stack."
;

native pop
  #eff "^stack -- x ^stack"
  #doc "Expects the top element to be a stack. Pops the top element off that stack, and pushes it onto the main stack."
;

native push
  #eff "x ^stack -- ^stack"
  #doc "Pushes x onto the stack."
;

native print
  #doc "Prints the top value of the stack such that it could be parsed again."
;

native write
  #doc "Prints the value represented by the the top value of the stack, i.e. '\x' prints 'x' and '"foo"" prints 'foo'."
;

# Protocols

protocol length
  #eff "a -- a ^i64"
  #doc "Pushes the length of 'a' onto the stack."
;

extend length ^list  :   list-length ;
extend length ^stack :  stack-length ;

# Functions

function empty?
  #eff "a -- a ^bool"
  #doc "Pushes true onto the stack if 'a' has a length of zero, otherwise pushes false."
:
  length 0 equal?
;

function roll-down
  #eff "x y z -- y z x"
:
  3 lift
;

function roll-up
  #eff "x y z -- z x y"
  : 3 push ;

function swap
  #eff "x y -- y x"
  #doc "Swaps the top two elements of the stack."
  : 2 lift ;

function dup
  #eff "x -- x x"
  #doc "Pushes another references to x onto the stack."
  : demote peek push promote ;

function dupd
  #eff "x y -- x x y"
  #doc "Pushes a copy of x onto the stack, keeping y on the top."
  : swap dup roll-down ;

function drop
  #eff "x --"
  #doc "Removes the top element of the stack."
  : demote pop promote ;

function drop2
  #eff "x y --"
  #doc "Removes the top two elements of the stack."
  : demote pop pop promote ;

function drop3
  #eff "x y --"
  #doc "Removes the top two elements of the stack."
  : demote pop pop pop promote ;

# TODO: drop-n

function dropd
  #eff "x y -- y"
  #doc "Removes x from the stack while keeping y."
  : swap drop ;

function swapd
  #eff "x y z -- y x z"
  #doc ""
  : 3 lift swap ;

function dip
  #eff "x ^list -- x"
  #doc "Evaluates List against the stack with out x, pushing x back onto the stack after.
  : swap demote pop pop stack-apply push promote ;

function if*
  #doc "Like if, except instead of a predicate list, expects a boolean."
  : roll-down 1 list roll-up if ;

function print-line
  #doc "Prints the top value of the stack such that it could be parsed again, followed by a new line."
  : print \newline write drop ;

function write-line
  #doc "Prints the value represented by the the top value of the stack, i.e. '\x' prints 'x' and '"foo"" prints 'foo', followed by a new line."
  : write \newline write drop ;

function !
  #doc "Prints the main stack."
  : demote write-line promote ;

function not
  #eff "^bool -- ^bool"
  #doc "Inverts the ^bool value at the top of th stack."
  : ( false ) ( true ) if* ;

function inc
  #eff "^i64 -- ^i64"
  #doc "Increments the integer at the top of the stack by one."
  : 1 + ;

function dec
  #eff "^i64 -- ^i64"
  #doc "Decrements the integer at the top of the stack by one."
  : 1 - ;

function zero?
  #eff "^i64 -- ^bool"
  : 0 equal? ;

function even?
  #eff "^i64 -- ^bool"
  : 2 % zero? ;

function odd?
  #eff "^i64 -- ^bool"
  : even? not ;
